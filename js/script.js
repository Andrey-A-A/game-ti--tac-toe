$(function() {
	
let player = 'x' //определяем переменную для пользователя x

//определяем выигрышные последовательности (массив)
let winCellIndex = [
//horizontal
	[0,1,2],[3,4,5],[6,7,8],
//vertikal
	[0,3,6],[1,4,7],[2,5,8],
//diagonal
	[0,4,8],[2,4,6]
]
//необходимо запомнить значение клетки выбранное пользователем. Создадим для этого объект
	let selectedCells = {
//значениями каждого свойства будет пустой массив, так как игроки еще не сделали ход
		'x':[],
		'o':[]
	}


//определяем действие по клику используя метод .on, а значит нужно обращаться не к самому элементу, а к его родителю
	$('.wrap').on('click','.cell:not(".cell-x,.cell-o")',oneStep)
//первым аргументом указываем метод click, а вторым аргументом указываем элемент, для которого создается обработчик события,
//а именно ячейка с классом .cell у которых отсутствует доболнительный класс либо .cell-x либо .cell-o (эти классы будут 
//присваиваться ячейкам, которые уже отмечены либо крестиком либо ноликом) 
//третьим аргументом указываем функцию обрабочтик oneStep

	function oneStep(event) { //even - объект события которое сработало

		let $cell = $(event.currentTarget)
//в данной переменной будет хранится клетка по которой в данный момент кликнули
//$cell - это просто переменная, символ $ ничего не значит, просто чтоб отличалось от других переменных cell(что означает клетка)
//свойство currentTarget хранит в себе объект того элемента, по которому был клик мышью, то есть представляет собой элемент HTML
//из которого мы получаем jQuery выборку
//Свойство currentTarget объекта Event определяет текущий элемент DOM, в котором в настоящий момент обрабатывается событие.
//Как правило, свойство currentTarget используется в том случае, когда один и тот же обработчик события присваивается нескольким
//элементам.
		//console.log($cell) //возвращает массивоподобный объект [div.cell] или в fox object { 0: div.cell ,length: 1}

		$cell.addClass('cell-' + player + ' offset-' + player)
//добавляем к выбранной клетке дополнительный класс с помощью метода addClass (получится cell-x или cell-o) и далее добавляем 
//ещё один класс offset-х или offset-o, который отвечает за смещение фона - спрайта (на изображении отображается x и о) 

//передадим выбранной ячейке порядковый номер
		let indexCell = $('.wrap .cell').index($cell)
//в переменную помещаем выборку всех ячеек, далее получаем индекс выбранной ячейки с помощьью метода .index, помещаем в него 
//объект выбранной ячейки 
//метод .index возвращяет индекс заданного элемента в наборе

//далее нам необходимо выбрать у объекта selectedCells свойство, которое соответствует конкретному пользователю, поэтому 
//создадим следующий массив
		let selectedCellsPlayer = selectedCells[player]

		//console.log(selectedCellsPlayer) 
		//console.log(selectedCells)
//у данного объекта нас интересует свойство имя которого мы узнаем из содержимого переменной player, в которой содержится как
//раз строка, характеризующая конкретного игрока. Данная строка соответствует именам свойств в объекте selectedCells
//Таким образом в переменной selectedCellsPlayer сейчас у нас содержится выбранное свойство из объекта selectedCells

//Теперь обратимся к свойству selectedCellsPlayer, в этом свойтсве должен хранится массив, а значит, чтобы добавить ячейку в 
//этот массив используем метод .push, и в качестве аргумента мы как раз указываем содержимое данной ячейки, а именно значение
//переменной indexCell, то есть порядковый номер клетки, по которой кликнул пользователь
 		selectedCellsPlayer.push(indexCell)
 		//console.log(selectedCellsPlayer) 
//таким образом в объект selectedCells в каждое свойство данного объекта мы записываем порядковые номера тех клеток по которым
//кликнул соответствующий пользователь

//теперь, когда мы получили уже значение и порядковый номер отмеченных клеток, нам необходимо определить, сложилась ли выигрышная
//позиция. Определять это будем с помощью функции checkWinner, которая описана ниже.
		checkWinner(selectedCellsPlayer)


//далее передадим очередь другому игроку
		if (player === 'x') {
			player = 'o' //если player имеет значение 'x', то присвоим ему значение 'o'
		}
		else player = 'x'
	}

//функция, которая определяет сложилась ли выигрышная позиция
	function checkWinner(selectedCellsPlayer) {
//пройдем в ццикле for многмерный массив выигрышных последовательностей winCellIndex
		for (var i = 0; i < winCellIndex.length; i++) {
			let allWinCells = true //по значению данной переменной мы будем оценивать выиграл ли пользователь или нет
			for (var j = 0; j < winCellIndex[i].length; j++) {

				if ($.inArray(winCellIndex[i][j],selectedCellsPlayer) === -1) { 
//метод .inArray проверяет содержится ли определенное значение (winCellIndex[i][j]) в массиве selectedCellsPlayer, заданным 
//вторым аргументом. Этот метод возвращает -1 если соответсвие не найдено, в этом случае значение переменной allWinCells = false
//winCellIndex[i][j] - это порядковый номер одной из выигрышной комбинации
//selectedCellsPlayer - это массив тех порядковых номеров клеток, по которым кликнул пользователь

					allWinCells = false
				}
			}

			if(allWinCells) { //если переменная allWinCells истина, то напишем игрок х или о выиграл!!!
				//alert('Игрок ' + player + ' выиграл!!!')
//далее нам нужно перечеркнуть выигрышную последовательность
				$('.cell').each(function(ind,elem) { //ind - индекс элемента в наборе (порядковый номер клетки), elem - элемент набора
//отбираем в набор все ячейки с помощью метода .each для каждого элемента выборки применяем функцию обработчик
					let cl = 'win'
					if($.inArray(ind,winCellIndex[i]) !== -1) {
//проверяем присутствует ли клетка с индексом ind в элементе (ячейке) массива выигрышных последовательностей winCellIndex[i]
//если было найдено совпадение, то есть результат данного метода не равен -1, то зачеркнем выигрышную последовательность
						//let cl = 'win' //создадим переменную для присвоения класса изображениям с зачеркиваниями
						if ( i <= 2) { 
//проверяем, чтобы выигрышные последовательности занимали позицию 0,1 или 2 в массиве winCellIndex, то есть в горизонтальную
//позицию
							cl += '0' //добавляем к имени класса изображения индекс 0, получим win0
						} else if( i >= 3 && i <= 5) {
//проверяем, чтобы выигрышные последовательности занимали позицию 3,4 или 5 в массиве winCellIndex, то есть в вертикальную
//позицию
							cl += '1' //добавляем к имени класса изображения индекс 1, получим win1
						}
						else
							cl += ($.inArray(0,winCellIndex[i])) ? '2' : '3'
//есть два вида диагонали, в одной выигрышная последовательность содержит 0, а в другой нет, поэтому с помощью тернарного 
//оператора определяем наличие 0 в последовательности, если есть, то добавляем 2, если нет, то 3
					}
//добавим смещение изображения
					cl += ' offset-' + player
//добавляем сформированный класс 
					$(this).addClass(cl) //this соответствует элементу (клетке), для которого вызывается функция обработчик
					
				})
//далее нам нужно отключить обработчик события click, так как игра уже окончена
				$('.wrap').off('click')
				//break
				alert('Игрок ' + player + ' выиграл!!!')
			}
//если в игре ничья - если allWinCells ложь, то есть нет выигрышной комбинации и длина массива с незаполненными ячейками равна 0
			if (!allWinCells && $('.cell:not(".cell-x,.cell-o")').length === 0) { 
				alert('Ходов больше нет!')
				$('.wrap').off('click')
				break //break указываем, тобы выйти из цикла, иначе сообщение alert зацикливается 
			}
		}
	}

});

